@startuml
/'
1) patterne Observer pour avoir une interface minimaliste   X
2) ajout interface pour bateau et player
3) ajout piège
4) ajout des armes
5) ajout du mode île
6) ajout du gameConfig

-- Mise à jour de l'interface minimaliste en conosole
   au fur et à mesure des différentes implémentations.
'/
skinparam linetype ortho


package Model{
    package Game{
        class Game{
            - player1 : Player
            - player2 : Player
            - gameOver : boolean
            - currentPlayer : Player
            - _observers : GameObserver

            + "create" Game(p1: Player, p2 : Player)
            + startGame() : void /' boucle du jeu'/
            + nextTurn() : void  /' initialise le tour en demandant au joueur de tirer'/
            + proccesTurn(coord : Coordinate) : void /' méthode appelé par le controller une fois le joueur ayant tirer'/
            + isFinished() : boolean
            + placeBoat(grid : Grid, boats : List <Boat>) : void
            + attachObserver(observer : GameObserver) : void
            + notifyTurn(player : Player) : void /' affiche l'état actuelle des grilles du joueur ainsi que son score ...'/
            + notifyAskPlayerToShot() : void /' demande au joueur de tirer et transmet les coordonnées au controller'/
            + notifyGrid(player : Player) : void /' affiche l'état des grilles du joueur après qu'il ait jouer'/
            + notifyGameOver(winner : Player, looser : Player) : void
        }

        interface GameObserver{
            + printTurn(player : Player) : void
            + askPlayerToShot() : void
            + printGrids(player : Player) : void
            + printEndGame(winner : Player, looser : Player) : void
        }
    }

    package Player{
        interface Player{
            + shotGridUpdate(coord : Coordinate, shotResult : gridEntity) : void
            + reciveShot(coord : Coordinate) : gridEntity
            + isDefeated() : boolean
        }

        class HumanPlayer implements Player{
            - name : string
            - nbBoatRemaining : integer
            - ownGrid : Grid
            - shotGrid : Grid

            + shotGridUpdate(coord : Coordinate, shotResult : gridEntity) : void
            + reciveShot(coord : Coordinate) : gridEntity
            + isDefeated() : boolean
        }
        class ComputerPlayer implements Player{
            - name : string
            - nbBoatRemaining : integer
            - ownGrid : Grid
            - shotGrid : Grid

            + shotGridUpdate(coord : Coordinate, shotResult : gridEntity) : void
            + reciveShot(coord : Coordinate) : GridEntity
            + shot() : Coordinate
            + isDefeated() : boolean
        }
    }

    package Map{
        class Grid{
            - grid [][] : gridCells
            - nbBoatRemaining : integer
            - ownBoats : List <Boat>
            - size : integer

            + checkContentCell(coord : Coordinate) : GridEntity
            + isBoatSunk(boat : Boat) : boolean
            + getBoatFromCoord(coord : Coordinate) : Boat
            + shotBoat(boat : Boat) : void
        }

        class GridCell{
            - position : Coordinate
            - content : GridEntity
            + updateContent(entity : GridEntity)
            + getContent() : GridEntity
        }
    }

    class Coordinate{
        - x : integer
        - y : integer

        + coordinateCmp(coord1 : Coordinate, coord2 : Coordinate) : boolean
        + coordinateSearch(lstCoord : List <Coordinate>, coord : Coordinate) : boolean
    }

    enum GridEntity{
        empty
        miss
        hit
        sunk
        boat
    }

    package Ships{
        interface Boat{
                + isSunk() : boolean
                + reciveShot() : void
        }

        class AircraftCarrier implements Boat{
            - position : List <Coordinate>
            - size : integer
            - nbShotRecive : integer

            + isSunk() : boolean
            + reciveShot() : void
        }

        class Cruiser implements Boat{
                - position : List <Coordinate>
                - size : integer
                - nbShotRecive : integer

                + isSunk() : boolean
                + reciveShot() : void
        }

        class Destroyer implements Boat{
                - position : List <Coordinate>
                - size : integer
                - nbShotRecive : integer

                + isSunk() : boolean
                + reciveShot() : void
        }

        class Submarine implements Boat{
                - position : List <Coordinate>
                - size : integer
                - nbShotRecive : integer

                + isSunk() : boolean
                + reciveShot() : void
        }

        class TorpedoBoat implements Boat{
                - position : List <Coordinate>
                - size : integer
                - nbShotRecive : integer

                + isSunk() : boolean
                + reciveShot() : void
        }
    }

    Game.Game *-> "2\n player1\n player2" Player.Player
    Game.Game -->  Map.Grid : <<use>>
    Game.Game -->  Boat : <<use>>
    Game.Game -->  Coordinate : <<use>>
    Game.Game -->  GridEntity : <<use>>
    Game.Game o-> "*\n_observers" Game.GameObserver : > notify

    Player.Player *--> "2\n ownGrid\n shotGrid" Map.Grid
    Player.Player -->  GridEntity : <<use>>
    Player.Player -->  Coordinate : <<use>>

    Map.Grid *--> "*\n _grid" GridCell
    Map.Grid *--> "1..*\n _ownBoat" Boat
    Map.Grid -->  Coordinate : <<use>>
    Map.Grid -->  GridEntity : <<use>>


    GridCell *--> "1\n position" Coordinate
    GridCell *--> "1\n content" GridEntity

    Boat *--> "1..*\n _position" Coordinate

    Game.GameObserver --> Player.Player : "<<use>>"

}
package view{
    class GameView implements Model.Game.GameObserver{
        + printTurn(player : Player) : void
        + askPlayerToShot() : void
        + printGrids(player : Player) : void
        + printEndGame(winner : Player, looser : Player) : void
    }
}

package Controller{
    class GameController{
        + sendShotCoord(coord : Coordinate) : void  /'méthode qui appellera la méthode processTurn dans la class Game'/
    }
}

GameView --> Controller.GameController
GameController --> Model.Game.Game

@enduml