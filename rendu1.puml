@startuml batailleNaval
package Controller {

}

package Model {

    interface Observer <<interface>> {
        + update()
    }

    interface GridEntity <<interface>> {
        + onHit(attacker: Player, coordinates: Coordinates) : ShotResult
        + getType(): String
    }

    ' implémenté plus tard getRelative pour les bombes etc
    ' equals pour comparé 2 coordonés
    class Coordinates {
        - row: Integer
        - column: Integer
        + <<create>> Coordinates(row: Integer, column: Integer)
        + equals(Object): boolean
        + toString(): String
    }

    ' Entity type pour le cas bateau/bombe
    ' class pour faire passer les résultas à travers les autres
    class ShotResult {
        - isHit: boolean
        - isSunk: boolean
        - entityType: String
        - Coordinates: Coordinates
        - message: String
        - isTrap: boolean
        - playerWeapon: Weapon

        + <<create>> ShotResult(isHit: boolean, isSunk: boolean, entityType: String, Coordinates: Coordinates, message: String)
        + isHit(): boolean
        + isSunk(): boolean
        + getEntityType(): String
        + getCoordinates(): Coordinates
        + getMessage(): String
        + isTrap(): boolean
        + getPlayerWeapon(): Weapon
    }

    GridEntity .right.> Coordinates : use

    package Map{
        ' placeEntity prend une liste car une entity occupe plusieurs case
        class Grid{
            - size: Integer
            - cells: GridCell[][]
            - observers: List<Observer>

            + <<create>> Grid(size: Integer)
            + attachObserver(Observer)
            + notifyObservers()
            + placeEntity(entity: GridEntity, coordinates: List<Coordinates>): boolean
            + getCell(coordinates: Coordinates): GridCell
        }
        ' indexInEntity : qu'elle index de l'entiter est touché
        class GridCell{
            - isHit: boolean
            - entity: GridEntity
            - indexInEntity: Integer

            + <<create>> GridCell(entity: GridEntity, indexInEntity: Integer)
            + hit(): ShotResult
            + isOccuped(): boolean
        }

        ShotResult .down.> Coordinates : contient
        Grid "1" *-- "*" GridCell
        GridCell "1" o-- "0..1" GridEntity
        Grid .down.> Coordinates : use
        Grid .down.> GridEntity : use
        GridCell .down.> GridEntity : use
    }
    package Boat{
        enum BoatType <<enumerate>> {
            AIRCRAFT_CARRIER
            CRUISER
            DESTROYER
            SUBMARINE
            TORPEDO
        }
        ' Interface design patern : Factory
        interface BoatFactory <<interface>>{
            + createBoat(BoatType): Boat
        }

        class SimpleBoatFactory implements BoatFactory{
            + createBoat(BoatType): Boat
        }

        ' un bateau est une entité de la grille
        interface Boat <<interface>> extends Model.GridEntity {
            + isSunk(): boolean
            + hit(index: Integer)
            + getSize(): Integer
            + getName(): String
        }
        class Submarine implements Boat{
            - size: Integer
            - hits: boolean[]

            + <<create>> Submarine()
            + isSunk(): boolean
            + hit(index: Integer)
            + getSize(): Integer
            + getName(): String
        }

        class Torpedo implements Boat{
            - size: Integer
            - hits: boolean[]

            + <<create>> Torpedo()
            + isSunk(): boolean
            + hit(index: Integer)
            + getSize(): Integer
            + getName(): String
        }

        class Destroyer implements Boat{
            - size: Integer
            - hits: boolean[]

            + <<create>> Destroyer()
            + isSunk(): boolean
            + hit(index: Integer)
            + getSize(): Integer
            + getName(): String
        }

        class Cruiser implements Boat{
            - size: Integer
            - hits: boolean[]

            + <<create>> Cruiser()
            + isSunk(): boolean
            + hit(index: Integer)
            + getSize(): Integer
            + getName(): String
        }

        class AircraftCarrier implements Boat{
            - size: Integer
            - hits: boolean[]

            + <<create>> AircraftCarrier()
            + isSunk(): boolean
            + hit(index: Integer)
            + getSize(): Integer
            + getName(): String
        }

        BoatFactory ..> Boat : create
        SimpleBoatFactory ..> Boat : create

        BoatFactory .up.> BoatType : use
        SimpleBoatFactory .up.> BoatType : use
    }

    package Player{
        interface Player <<interface>>{
            + isDefeated(): boolean
            + shoot(coord: Coordinates, weapon: Weapon): ShotResult
            + receiveShot(coord: Coordinates, weapon: Weapon): ShotResult
            + update()
        }

        class HumanPlayer implements Player {
            - name: String
            - myGrid: Grid
            - shotsGrid: Grid
            - observers: List<Observer>

            + <<create>> HumanPlayer(name: String, myGrid: Map.Grid, shotsGrid: Map.Grid)
            + shoot(coord: Coordinates, weapon: Weapon): ShotResult
            + receiveShot(coord: Coordinates, weapon: Weapon): ShotResult
            + attachObserver(Observer)
            + notifyObservers()
            + isDefeated(): boolean
            + update()
            + notifyObservers()
        }
    }

    package Weapon{
        interface Weapon <<interface>> {
            + apply(targetPlayer: Player, targetCoord: Coordinates): ShotResult
            + getName(): String
            + getUsesLeft(): Integer
        }

        class Bombe implements Weapon{
            - useLeft: Integer
            + <<create>> Bombe()
            + apply(targetPlayer: Player, targetCoord: Coordinates): ShotResult
            + getName(): String
            + getUsesLeft(): Integer
            + use()
        }

        class Sonar implements Weapon{
            - useLeft: Integer
            + <<create>> Sonar()
            + apply(targetPlayer: Player, targetCoord: Coordinates): ShotResult
            + getName(): String
            + getUsesLeft(): Integer
            + use()
        }

        Weapon .up.> Model.Player.Player : use
        Weapon .up.> Coordinates : use
        Weapon .up.> ShotResult : return
    }

    package Trap{
        class BlackHole implements Model.GridEntity{
            - size: Integer

            + <<create>> BlackHole()
            + onHit(attacker: Player::Player, coordinates: Coordinates): ShotResult
            + getType(): String
            + getSize(): Integer
        }

        class Tornado implements Model.GridEntity{
            - size: Integer
            - turnsLEft: Integer
            + <<create>> Tornado()

            + onHit(attacker: Player::Player, coordinates: Coordinates): ShotResult
            + getType(): String
            + getSize(): Integer
        }

        Trap .up.> Coordinates : use
    }

    package Island{
        interface IslandItem <<interface>>{
            +onFind(player: Player)
        }

        class IslandEmpty implements IslandItem {
            + <<create>> IslandEmpty()
            + onFind(player: Player::Player): ShotResult
        }

        class BombItem implements IslandItem {
            + <<create>> BombItem()
            + onFind(player: Player): ShotResult
        }

        class SonarItem implements IslandItem {
            + <<create>> SonarItem()
            + onFind(player: Player): ShotResult
        }
    }

    package Game{
        class GameConfiguration(){
            - gridSize: Integer
            - boatCounts: Map<BoatType, Integer>
            - isIslandMode: boolean
            - numSpecialItems: Integer
            - computerShotLevel: Integer
            - placementLevel: Integer ' D4, D10

            + <<create>> GameConfiguration(size: Integer, boatMap: Map<Boat::BoatType, Integer>, island: boolean, level: Integer)
            ' Faut que j'implémente les getters encore
        }

        class Game{
            - humanPlayer: Player::HumanPlayer
            - computerPlayer: ComputerPlayer
            - config: GameConfiguration
            - observers: List<Observer>
            - turnNumber: Integer

            + <<create>> Game(config: GameConfiguration, hp: HumanPlayer, cp: ComputerPlayer)

            ' observer
            + attachObserver(Observer): void
            + notifyObservers(): void

            ' gestion de la partie
            + startGame(): void
            + processHumanTurn(coord: Coordinates, weapon: Weapon): ShotResult
            + processComputerTurn(): ShotResult
            + isGameOver(): boolean ' D6
            + restartGame(config: GameConfiguration): void ' D7
            + nextTurn(): void
        }
    }
}

package View {
    class MainScreen{}
    class EndScreen{}
    class ConfigurationScreen{}
    class PlacementScreen{}
}
@enduml